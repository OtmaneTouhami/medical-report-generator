#!/usr/bin/env python
import sys
import warnings
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
import re

from medical_report_generator.crew import MedicalReportGenerator

warnings.filterwarnings("ignore", category=SyntaxWarning, module="pysbd")


def create_word_document(report_text: str, filename: str = "radiology_report.docx"):
    """
    Creates a Word document from the structured report text generated by the crew.

    Args:
        report_text: The complete structured report text (output from the crew).
        filename: The name of the output .docx file.
    """
    document = Document()

    style = document.styles["Normal"]
    font = style.font
    font.name = "Calibri"
    font.size = Pt(11)

    # --- Remove markdown code block fences ---
    cleaned_text = re.sub(
        r"^\s*```(?:json|text)?\s*[\r\n]*(.*?)\s*```\s*$",
        r"\1",
        report_text,
        flags=re.DOTALL | re.IGNORECASE,
    ).strip()

    lines = cleaned_text.split("\n")

    title_content = "Radiology Report"
    lines_for_sections = lines

    if lines:
        first_line = lines[0].strip()
        if first_line.startswith("TITRE:"):
            # Extract content after "TITRE:"
            title_content = (
                first_line.split(":", 1)[1].strip()
                if ":" in first_line
                else "Radiology Report"
            )
            lines_for_sections = lines[1:]  # Remove title line for section parsing

    # Add the extracted or default title
    title_paragraph = document.add_paragraph(title_content)
    title_paragraph.style = document.styles["Heading 1"]  # Or use a custom style
    title_paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
    document.add_paragraph()  # Add a blank line after the title

    # --- Improved Section Parsing ---
    section_headers_list = [
        "Indication:",
        "Technique:",
        "Incidences:",
        "RÃ©sultat:",
        "Conclusion:",
    ]
    report_sections_data = {}

    # Process lines_for_sections to populate report_sections_data
    for line in lines_for_sections:
        stripped_line = line.strip()
        found_header = False
        for header in section_headers_list:
            if stripped_line.startswith(header):
                # Found a header line. Extract content *after* the header on the same line.
                content_after_header = stripped_line[len(header) :].strip()
                report_sections_data[header] = (
                    content_after_header  # Store content directly under the header key
                )
                break  # Found header, stop checking other headers for this line
        # Note: Based on the LLM's current output format, section content
        # seems to be entirely on the header line. If the LLM output format
        # changes to multi-line content per section, this parsing logic
        # would need a more complex state machine approach.

    # Add sections to the document in the defined order
    for header in section_headers_list:
        # Retrieve the processed content. Use .get() to handle cases where a header might
        # not have been present in the cleaned text lines (unlikely with the current tasks, but safer).
        content = report_sections_data.get(
            header, ""
        ).strip()  # Get content, default to empty string

        paragraph = document.add_paragraph()
        header_run = paragraph.add_run(header)
        header_run.bold = True
        paragraph.add_run(" ")  # Space after header

        # Add the content or placeholder
        if content and content != "-":
            paragraph.add_run(content)
        else:
            paragraph.add_run(
                "-"
            )  # Add placeholder if content is empty or just the placeholder "-"

        # Add a blank line AFTER each section paragraph
        document.add_paragraph()

    try:
        document.save(filename)
        print(f"\nReport successfully generated as '{filename}'")
    except Exception as e:
        print(f"\nError saving document: {e}")
        # Exit or raise error if document saving fails - important for script robustness
        sys.exit(1)


def run():
    """
    Run the crew to generate a medical report.
    """
    print("## Medical Report Generation Crew")
    print("-------------------------------")

    # Define the raw medical input text
    raw_medical_input = """
Hello, here is the information regarding this 48-year-old patient who presents with left knee pain that appeared after a twist during a football match three days ago. The clinical presentation includes difficulty bearing weight and a sensation of joint instability. The request was to investigate for a possible meniscal or ligamentous injury.

The MRI examination performed on the left knee used standard T1 and T2-weighted sequences with fat suppression (SPIR) in three planes.

The images show, within the medial meniscus, an intrameniscal T2 increased signal intensity without communication with the articular surface, corresponding to a Grade 2 lesion according to Stoller. The lateral meniscus appears normal.

Regarding the anterior cruciate ligament (ACL), there is thickening with partial increased signal intensity, suggesting a low-grade sprain (Grade 1 or 2) with partial preservation of fibers. The collateral ligaments and the posterior cruciate ligament (PCL) are intact.

The articular cartilage appears normal for the patient's age. There is a small intra-articular effusion, without associated fracture or significant bone bruise, only a slight reaction at the lateral tibial plateau.

In summary, these radiological findings are suggestive of a low-grade partial left ACL sprain associated with a Grade 2 medial meniscal lesion, accompanied by a small reactive effusion.

To be correlated with the clinical examination for therapeutic guidance.
    """

    # Define the inputs for the first task
    inputs = {"raw_input": raw_medical_input}

    # Instantiate the Crew using the CrewBase class, passing the LLM
    try:
        crew_generator = MedicalReportGenerator()
        crew = crew_generator.crew()

        # Kick off the crew process
        print("\nStarting the crew process...")
        # Call str() on the result to get the final text output
        result = str(crew.kickoff(inputs=inputs))
        print("\nCrew process finished.")

        print("\n## Generated Report Text:")
        print(result)
        print("-------------------------------")

        # Generate the .doc file from the final report text
        create_word_document(result, filename="radiology_report.docx")

    except Exception as e:
        # Print a more informative error message including the exception type
        print(
            f"\nAn error occurred during crew execution or document generation: {type(e).__name__}: {e}",
            file=sys.stderr,
        )
        sys.exit(1)  # Exit with a non-zero code to indicate an error


# Keep the other functions as placeholders
def train():
    """
    Train the crew for a given number of iterations.
    Note: Training functionality might require specific setup
    and might not be fully supported or necessary for all LLM providers
    or Hugging Face hosted models via the standard API.
    """
    print("Crew training is not fully implemented or tested with this LLM setup.")
    print("Adjust the train function based on CrewAI and LLM provider documentation.")


def replay():
    """
    Replay the crew execution from a specific task.
    Note: Replay requires logging and persistence setup in CrewAI.
    """
    print("Crew replay is not fully implemented or tested with this setup.")
    print("Adjust the replay function based on CrewAI documentation.")


def test():
    """
    Test the crew execution and returns the results.
    Note: Testing functionality might require specific setup.
    """
    print("Crew testing is not fully implemented or tested with this setup.")
    print("Adjust the test function based on CrewAI documentation.")


# Entry point for the script
if __name__ == "__main__":
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        if command == "run":
            run()
        elif command == "train":
            train()
        elif command == "replay":
            replay()
        elif command == "test":
            test()
        else:
            print(f"Unknown command: {command}", file=sys.stderr)
            print("Usage: python main.py [run|train|replay|test]", file=sys.stderr)
            sys.exit(1)
    else:
        run()  # Default command
