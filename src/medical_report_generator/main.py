#!/usr/bin/env python
import sys
import warnings
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
import re
import random
from pathlib import Path
from datetime import datetime

from medical_report_generator.crew import MedicalReportGenerator

warnings.filterwarnings("ignore", category=SyntaxWarning, module="pysbd")


def create_word_document(report_text: str, filename: str = "radiology_report.docx"):
    """
    Creates a Word document from the structured report text generated by the crew.

    Args:
        report_text: The complete structured report text (output from the crew).
        filename: The name of the output .docx file.
    """
    document = Document()

    style = document.styles["Normal"]
    font = style.font
    font.name = "Calibri"
    font.size = Pt(11)

    # Regex to remove markdown code block fences, including 'french'
    cleaned_text = re.sub(
        r"^\\s*```(?:json|text|french)?\\s*[\\r\\n]*(.*?)\\s*```\\s*$",
        r"\\1",
        report_text,
        flags=re.DOTALL | re.IGNORECASE,
    ).strip()

    lines = cleaned_text.split("\n")

    title_content = "Compte Rendu Radiologique"
    lines_for_sections = lines

    if lines:
        first_line = lines[0].strip()
        # Case insensitive check for TITRE, supporting French output
        if first_line.upper().startswith("TITRE:"):
            title_content = (
                first_line.split(":", 1)[1].strip()
                if ":" in first_line
                else title_content
            )
            lines_for_sections = lines[1:]

    # Add the extracted or default title
    title_paragraph = document.add_paragraph(title_content)
    title_paragraph.style = document.styles["Heading 1"]
    title_paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
    document.add_paragraph()  # Add a blank line after the title

    # --- Improved Section Parsing ---
    section_headers_list = [
        "Indication:",
        "Technique:",
        "Incidences:",
        "Résultat:",
        "Conclusion:",
    ]
    report_sections_data = {}
    current_section_header = None
    current_section_content = []

    # Improved section parsing for potentially multi-line content within sections
    for line_idx, line_text in enumerate(lines_for_sections):
        stripped_line = line_text.strip()
        found_new_header = False
        for header in section_headers_list:
            if stripped_line.upper().startswith(header.upper()):
                if current_section_header:
                    report_sections_data[current_section_header] = "\n".join(
                        current_section_content
                    ).strip()
                current_section_header = header
                current_section_content = [stripped_line[len(header) :].strip()]
                found_new_header = True
                break
        if not found_new_header and current_section_header:
            if stripped_line:
                current_section_content.append(stripped_line)

        if line_idx == len(lines_for_sections) - 1 and current_section_header:
            report_sections_data[current_section_header] = "\n".join(
                current_section_content
            ).strip()

    # Add sections to the document in the defined order
    for header in section_headers_list:
        content = report_sections_data.get(header, "").strip()
        paragraph = document.add_paragraph()
        header_run = paragraph.add_run(header)
        header_run.bold = True
        paragraph.add_run(" ")

        if content and content != "-" and content.upper() != "NÉANT":
            paragraph.add_run(content)
        else:
            paragraph.add_run("Néant")
        document.add_paragraph()

    try:
        document.save(filename)
        print(f"\nCompte rendu généré avec succès sous le nom '{filename}'")
        return {"is_generated": True, "filename": filename}
    except Exception as e:
        print(f"\nErreur lors de l'enregistrement du document : {e}")
        sys.exit(1)
        return {"is_generated": False, "error": str(e)}


def run(medical_input: str = None):
    """
    Run the crew to generate a medical report.
    """
    print("## Équipe de Génération de Compte Rendu Médical")
    print("-------------------------------")

    # Using the French input example for endometriosis
    raw_medical_input = """
Patiente de 38 ans, adressée pour bilan de douleurs pelviennes chroniques avec dysménorrhée et dyspareunie profondes. Suspicion d'endométriose.
Antécédents : RAS.
Dernières règles : J10 du cycle.
L'examen IRM pelvien a été réalisé sur une antenne de 1.5 Tesla, avec des séquences axiales T1, axiales et sagittales T2, axiales T2 avec saturation de graisse, et des séquences de diffusion. Injection de Gadolinium non réalisée.
Résultats :
Utérus antéversé, de taille normale. Myomètre homogène. Cavité utérine sans particularité. Zone jonctionnelle d'épaisseur normale.
Ovaires en position normale, de taille et morphologie conservées, sans kyste suspect.
Pas d'anomalie significative au niveau des trompes.
Présence de quelques petits foyers d'hypersignal T1 spontané et T2 variable au niveau du cul-de-sac de Douglas et sur le ligament utéro-sacré gauche, compatibles avec des implants d'endométriose superficielle. Le plus large mesure environ 4mm.
Pas d'atteinte du torus utérin.
Pas de signe d'adénomyose.
Pas d'endométriome visible.
Pas d'atteinte digestive ou urinaire évidente sur cet examen (limites de la technique pour les atteintes digestives superficielles sans préparation spécifique).
Conclusion : Quelques petits implants d'endométriose superficielle visibles au niveau du cul-de-sac de Douglas et du ligament utéro-sacré gauche. Pas de signe d'endométriose profonde ou d'endométriome sur cet examen.
    """

    # Define the inputs for the first task
    inputs = {
        "raw_input": medical_input if medical_input is not None else raw_medical_input
    }

    # Instantiate the Crew using the CrewBase class, passing the LLM
    try:
        crew_generator = MedicalReportGenerator()
        crew = crew_generator.crew()

        # Kick off the crew process
        print("\nDémarrage du processus de l'équipe...")
        # Call str() on the result to get the final text output
        result = str(crew.kickoff(inputs=inputs))
        print("\nProcessus de l'équipe terminé.")

        print("\n## Texte du Compte Rendu Généré:")
        print(result)
        print("-------------------------------")

        current_file_path = Path(__file__).resolve()
        project_root = current_file_path.parent.parent.parent
        unique_name = datetime.now().strftime("radiology_report_%Y-%m-%d-%H-%M-%S.docx")
        generated_report_path_absolute = (
            project_root / "generated" / "reports" / unique_name
        )
        generated_report_path_relative = (
            Path("generated") / "reports" / unique_name
        ) 

        # Generate the .doc file from the final report text
        document_generation_status = create_word_document(
            result, filename=generated_report_path_absolute
        )

        # If successful, replace the absolute path with the relative path string in the return value
        if document_generation_status["is_generated"]:
            document_generation_status["filename"] = str(generated_report_path_relative)

        return document_generation_status

    except Exception as e:
        # Print a more informative error message including the exception type
        print(
            f"\nUne erreur s'est produite lors de l'exécution de l'équipe ou de la génération du document : {type(e).__name__}: {e}",
            file=sys.stderr,
        )
        sys.exit(1)  # Exit with a non-zero code to indicate an error


# Keep the other functions as placeholders
def train():
    """
    Train the crew for a given number of iterations.
    Note: Training functionality might require specific setup
    and might not be fully supported or necessary for all LLM providers
    or Hugging Face hosted models via the standard API.
    """
    print(
        "L'entraînement de l'équipe n'est pas complètement implémenté ou testé avec cette configuration LLM."
    )
    print("Adjust the train function based on CrewAI and LLM provider documentation.")


def replay():
    """
    Replay the crew execution from a specific task.
    Note: Replay requires logging and persistence setup in CrewAI.
    """
    print(
        "La relecture de l'équipe n'est pas complètement implémentée ou testée avec cette configuration."
    )
    print("Adjust the replay function based on CrewAI documentation.")


def test():
    """
    Test the crew execution with sample reports from the testing set.
    Evaluates the model's performance on previously unseen examples.
    """
    print("## Test du Générateur de Compte Rendu Médical")
    print("-------------------------------")

    current_file_path = Path(__file__).resolve()
    project_root = current_file_path.parent.parent.parent
    test_reports_path = project_root / "knowledge" / "reports" / "testing"
    output_test_reports_path = project_root / "generated" / "testing_outputs"
    output_test_reports_path.mkdir(parents=True, exist_ok=True)

    print(f"Chemin du fichier actuel : {current_file_path}")
    print(f"Racine du projet calculée : {project_root}")
    print(f"Recherche des rapports de test à : {test_reports_path}")

    if not test_reports_path.exists():
        print(
            f"Erreur : Le répertoire des rapports de test n'a pas été trouvé à {test_reports_path}"
        )
        sys.exit(1)

    test_files = list(test_reports_path.glob("*.txt"))
    if not test_files:
        print(f"Erreur : Aucun fichier de test trouvé dans {test_reports_path}")
        sys.exit(1)

    selected_test_file = random.choice(test_files)
    print(f"\nFichier de test sélectionné : {selected_test_file.name}")

    try:
        with open(selected_test_file, "r", encoding="utf-8") as f:
            ground_truth_report_text = f.read()

        prompt_input = ""
        lines = ground_truth_report_text.splitlines()
        capture = False
        # Extract "Indication:" section as prompt, case-insensitive, for French
        for line in lines:
            stripped_line = line.strip()
            if stripped_line.upper().startswith("INDICATION:"):
                prompt_input += stripped_line[len("INDICATION:") :].strip() + " "
                capture = True
            elif capture and not any(
                sh.upper() in stripped_line.upper()
                for sh in ["TECHNIQUE:", "INCIDENCES:", "RÉSULTAT:", "CONCLUSION:"]
            ):
                if stripped_line:
                    prompt_input += stripped_line + " "
            elif capture and any(
                sh.upper() in stripped_line.upper()
                for sh in ["TECHNIQUE:", "INCIDENCES:", "RÉSULTAT:", "CONCLUSION:"]
            ):
                break
        prompt_input = prompt_input.strip()

        if not prompt_input:
            print(
                f"Avertissement : Impossible d'extraire l'indication pour {selected_test_file.name}. Utilisation d'une invite générique."
            )
            prompt_input = "Patiente consultant pour des douleurs pelviennes et suspicion d'endométriose."  # Generic French fallback

        print(f"\nInvite générée pour l'équipe :\n{prompt_input}")
        print("-------------------------------")

        inputs = {"raw_input": prompt_input}
        # Use the full crew for testing
        crew_generator = MedicalReportGenerator()
        crew = crew_generator.crew()

        print("\nDémarrage du processus de l'équipe pour le test...")
        generated_report_text = str(crew.kickoff(inputs=inputs))
        print("\nProcessus de l'équipe de test terminé.")
        print("\n## Texte du Compte Rendu Généré (Test):")
        print(generated_report_text)
        print("-------------------------------")

        generated_report_filename_docx = (
            output_test_reports_path / f"generated_{selected_test_file.stem}.docx"
        )
        generated_report_filename_txt = (
            output_test_reports_path / f"generated_{selected_test_file.stem}.txt"
        )

        create_word_document(
            generated_report_text, filename=str(generated_report_filename_docx)
        )

        with open(generated_report_filename_txt, "w", encoding="utf-8") as f:
            f.write("--- INVITE UTILISÉE ---\n")
            f.write(prompt_input + "\n\n")
            f.write("--- COMPTE RENDU GÉNÉRÉ ---\n")
            f.write(generated_report_text + "\n\n")
            f.write("--- COMPTE RENDU DE RÉFÉRENCE (GROUND TRUTH) ---\n")
            f.write(ground_truth_report_text)
        print(
            f"Rapport de test (comparaison) sauvegardé en .txt : {generated_report_filename_txt}"
        )

        print("\n## Comparaison (Manuelle pour l'instant):")
        print(f"Rapport original (vérité terrain) : {selected_test_file.name}")
        print(
            f"Le rapport généré a été sauvegardé ici : {generated_report_filename_docx}"
        )
        print("Veuillez comparer manuellement le contenu et la structure.")
        print("-------------------------------")

    except FileNotFoundError:
        print(f"Erreur : Le fichier de test {selected_test_file} n'a pas été trouvé.")
    except Exception as e:
        print(
            f"\nUne erreur s'est produite lors de l'exécution du test : {type(e).__name__}: {e}",
            file=sys.stderr,
        )


# Entry point for the script
if __name__ == "__main__":
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        if command == "run":
            run()
        elif command == "train":
            train()
        elif command == "replay":
            replay()
        elif command == "test":
            test()
        else:
            print(f"Commande inconnue : {command}")
            print("Commandes disponibles : run, test, train, replay")
    else:
        print("Aucune commande fournie. Exécution de la commande 'run' par défaut.")
        run()  # Default command
